% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qm_matching.R
\name{qm_matching}
\alias{is.qm_matching}
\alias{qm_matching}
\title{\code{qm_matching} objects}
\usage{
qm_matching(labels, unassigned_labels = NULL, ids = NULL)

is.qm_matching(obj)
}
\arguments{
\item{labels}{vector with labels describing the matched groups.}

\item{unassigned_labels}{labels denoting unassigned data points.
\code{NA} values are always considered unassigned.}

\item{ids}{vector with IDs for the data points. If \code{NULL},
the IDs are set to \code{1:length(labels)}.}

\item{obj}{object to check.}
}
\value{
The \code{qm_matching} function returns a \code{qm_matching} object.

        \code{is.qm_matching} returns \code{TRUE} if \code{obj} is valid,
        otherwise \code{FALSE}.
}
\description{
Construct and check \code{qm_matching} objects.
}
\details{
The \code{qm_matching} function constructs a \code{qm_matching} object
from existing matching labels. This is useful when one uses the estimators in
the package with a matching not constructed by the \code{\link{quickmatch}}
function.

\code{is.qm_matching} checks whether the provided object
is a valid instance of the \code{qm_matching} class.
It does not check whether the matching it describes is sensible.
See \code{\link[Rscclust]{check_clustering}} for a function
that provides such checks.

\code{qm_matching} objects are based on integer vectors, and it indexes
matched groups starting with zero. The \code{qm_matching} class
inherits from the \code{\link[Rscclust]{Rscc_clustering}} class in
\code{Rscclust}.
}
\examples{
# Ten units in three matched groups
qm_matching(c("A", "B", "B", "C", "B", "C", "A", "A", "C", "C"))

# Label "999" denotes, in this example, units not assigned to a matched group
qm_matching(c("A", "999", "B", "C", "B", "999", "A", "A", "C", "C"),
            unassigned_labels = "999")

# Equivalent to previous command
qm_matching(c("A", NA, "B", "C", "B", NA, "A", "A", "C", "C"))

# Custom IDs
qm_matching(c("A", "B", "B", "C", "B", "C", "A", "A", "C", "C"),
            ids = letters[1:10])

# Check whether constructed object is a qm_matching
is.qm_matching(qm_matching(c("A", "B", "B", "C")))

}

